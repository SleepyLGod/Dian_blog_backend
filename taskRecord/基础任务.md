## 抽象类和接口的区别

这里我们定义一些继承。

```java
class Person {
    public void run() { … }
}

class Student extends Person {
    @Override
    public void run() { … }
}

class Teacher extends Person {
    @Override
    public void run() { … }
}

class MathTeacher extends Teacher {
    @Override
    public void run() { … }
}
```

如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法。

如果一个`class`定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用`abstract`修饰。因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。我们无法实例化一个抽象类，抽象方法实际上相当于定义了“规范”。

```java
public class Main {
    public static void main(String[] args) {
        Person p = new Student();
        p.run();
    }
}

abstract class Person {
    public abstract void run();
}

class Student extends Person {
    @Override
    public void run() {
        System.out.println("Student.run");
    }
}

```

当我们定义了抽象类`Person`，以及具体的`Student`、`Teacher`子类的时候，我们可以通过抽象类`Person`类型去引用具体的子类的实例：

```java
Person s = new Student();
Person t = new Teacher();
```

这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。

面向抽象编程的本质就是：

- 上层代码只定义规范（例如：`abstract class Person`）；

- 不需要子类就可以实现业务逻辑（正常编译）；

- 具体的业务逻辑由不同的子类实现，调用者并不关心。

  

如果一个抽象类没有字段，所有方法全部都是抽象方法：

```java
abstract class Person {
    public abstract void run();
    public abstract String getName();
}
```

就可以把该抽象类改写为接口：`interface`:

```java
interface Person {
    void run();
    String getName();
    default public void sayHello() {
		System.out.println("Hello");
	}
}
// 因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来
// 具体的class去实现一个interface:
class Student implements Person {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        System.out.println(this.name + " run");
    }

    @Override
    public String getName() {
        return this.name;
    }
}
```

>  实现类可以不必覆写`default`方法。`default`方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是`default`方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。`interface`没有字段，`default`方法无法访问字段，而抽象类的普通方法可以访问实例字段。

抽象类和接口的对比如下：

**相同点**

+ 都不能被实例化 
+ 接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。

**不同点**

|            |                  abstract class                   |                          interface                           |
| :--------- | :-----------------------------------------------: | :----------------------------------------------------------: |
| 继承       |               只能extends一个class                | class可以implements多个interface，interface继承自interface使用extends |
| 字段       |                 可以定义实例字段                  |                       不能定义实例字段                       |
| 抽象方法   |                 可以定义抽象方法                  |              可以定义抽象方法，不能有方法的实现              |
| 非抽象方法 |                可以定义非抽象方法                 |                     可以定义default方法                      |
| 成员变量   | 默认default，可在子类中被重新定义，也可被重新赋值 |  Java 9+，默认为public static final，必须赋初值，不能被修改  |

接口只能是功能的定义，而抽象类既可以为功能的定义也可以为功能的实现。



## 使用**postman**对`HelloDemo`调试

+ 传参id=321
+ 返回`hello 321 `

### GET请求 & path info传参

> ```java
> package com.hellodemo.hellodemo.controller;
> 
> import org.springframework.web.bind.annotation.PathVariable;
> import org.springframework.web.bind.annotation.RequestMapping;
> import org.springframework.web.bind.annotation.RequestMethod;
> import org.springframework.web.bind.annotation.RestController;
> 
> /**
>  * path info
>  * @PathVaribale 获取url中的数据
>  * http://localhost:8080/id=xxx
>  */
> @RestController
> public class HelloController {
>     @RequestMapping(value = "/id={id}",method = RequestMethod.GET)
>     // or: @GetMapping("/id={id}")
>     public String sayHello( @PathVariable("id") Integer id ) {
>         System.out.println(id);
>         return "hello " + id ;
>     }
> }
> ```

### GET请求 & URL Query String传参

> ```java
> package com.hellodemo.hellodemo.controller;
> 
> import org.springframework.web.bind.annotation.*;
> 
> /**
>  * URL Query String
>  * @RequestParam 获取请求参数的值
>  * http://localhost:8080/?id=xxx
>  */
> 
> @RestController
> public class HelloController2 {
>     @RequestMapping(value = "",method = RequestMethod.GET)
>     // or : @GetMapping(""）
>     public String sayHello2(@RequestParam Integer id) {
>         System.out.println(id);
>         return "hello "+id;
>     }
> }
> ```

### POST请求 & Body 传参（Content-type: application/json）

> ```java
> package com.hellodemo.hellodemo.controller;
> 
> import org.springframework.web.bind.annotation.*;
> import java.io.IOException;
> import java.util.Date;
> import java.util.logging.FileHandler;
> import java.util.logging.Formatter;
> import java.util.logging.Level;
> import java.util.logging.LogRecord;
> import java.util.logging.Logger;
> import org.apache.commons.logging.Log;
> import org.apache.commons.logging.LogFactory;
> 
> /**
>  * Body
>  * @RequestBody 传过来的参数自动封装成实体类对象
>  * http://localhost:8080/yourId1
>  */
> 
> @RestController
> public class HelloController3 {
>     @RequestMapping(value = "/yourId1", method = RequestMethod.POST)
>     // or: @PostMapping("/yourId1")
>     public String yourId1( @RequestBody YourId yourid /*, @RequestHeader(value = "id") Integer id */ ) {
>         System.out.println(yourid.getId());
>         System.out.println("id: " + yourid.getId());
>         return "hello " + yourid.getId();
>      }
> }
> ```

### POST 请求 & URL Query String传参

> ```java
> package com.hellodemo.hellodemo.controller;
> 
> 
> import org.springframework.web.bind.annotation.*;
> 
> 
> /**
>  * Body
>  * @RequestParam 将请求参数绑定到你控制器的方法参数上
>  * http://localhost:8080/yourId2
>  */
> 
> @RestController
> public class HelloController4 {
>     @RequestMapping(value = "/yourId2", method = RequestMethod.POST)
>     // or: @PostMapping("/yourId2")
>     public String yourId2(@RequestParam(value = "arr") String arr, @RequestParam(value = "id", required = false) int id ) {
>         System.out.println(id);
>         return "hello " + id;
>     }
> }
> ```

### POST请求 & Body 传参 &Headers传参

> ```java
> package com.hellodemo.hellodemo.controller;
> 
> import org.springframework.web.bind.annotation.*;
> 
> /**
>  * Body & Headers
>  * @RequestBody 传过来的参数自动封装成实体类对象
>  *  @RequestHeader 接收键名，形参为值；
>  * http://localhost:8080/yourId1
>  */
> 
> @RestController
> public class HelloController5 {
>     @RequestMapping(value = "/yourId3", method = RequestMethod.POST)
>     // or: @PostMapping("/yourId3")
>     public String yourId1( @RequestBody YourId yourid, @RequestHeader(value = "id") Integer id ) {
>         System.out.println(yourid.getId());
>         System.out.println("id: " + yourid.getId());
>         return "hello " + yourid.getId();
>     }
> }
> ```

